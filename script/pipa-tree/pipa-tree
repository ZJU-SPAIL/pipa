#!/usr/bin/env bash
set -euo pipefail

PROGRAM_NAME="pipa-tree"
PROGRAM_VERSION="0.1.0"

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Library directory resolution
# Priority: 1. Environment variable PIPA_TREE_LIB_DIR
#           2. Installed lib path (/usr/local/lib/pipa-tree)
#           3. Local lib subdirectory (for development)
if [[ -n "${PIPA_TREE_LIB_DIR:-}" ]]; then
  LIB_DIR="$PIPA_TREE_LIB_DIR"
elif [[ -d "/usr/local/lib/pipa-tree" ]]; then
  LIB_DIR="/usr/local/lib/pipa-tree"
else
  LIB_DIR="${SCRIPT_DIR}/lib"
fi

# Source library modules
source "${LIB_DIR}/common.sh"
source "${LIB_DIR}/spec_info.sh"
source "${LIB_DIR}/perf.sh"
source "${LIB_DIR}/sar.sh"
source "${LIB_DIR}/archive.sh"

PIPA_TREE_DATA_DIR="${PIPA_TREE_DATA_DIR:-$PWD/data}"
mkdir -p "$PIPA_TREE_DATA_DIR"
export PIPA_TREE_DATA_DIR

show_main_usage() {
  cat <<'EOF'
Usage: pipa-tree <command> [options]

Commands:
  collect      Run the collection process
  help         Show this message

Invoking pipa-tree without a subcommand is equivalent to running "pipa-tree collect".
EOF
}

show_collect_usage() {
  cat <<'EOF'
Usage:
  pipa-tree collect [--output PATH] [options]

Options:
  --output PATH               Destination .tar.gz archive path (defaults to ./pipa-collection-<timestamp>.tar.gz).
  --duration-stat SEC         Duration for counting phase (perf stat + sar, default: 60).
  --duration-record SEC       Duration for profiling phase (perf record, default: 60).
  --no-stat                   Disable counting phase collectors.
  --no-record                 Disable profiling phase collector.
  --perf-stat-interval MS     perf stat sampling interval (default: 1000ms).
  --sar-interval SEC          sar sampling interval (default: 1s).
  --perf-record-freq HZ       perf record frequency (default: 99Hz).
  --perf-events LIST          Override default perf event groups.
  --no-spec-info              Skip spec info validation/copy.
  --force-spec-refresh        Force re-collecting hardware spec even if cached.
  --help, -h                  Show this help.
EOF
}

read_machine_identifier() {
  if [[ -f /etc/machine-id ]]; then
    head -n 1 /etc/machine-id | tr -d '[:space:]'
    return
  fi
  if command -v hostid >/dev/null 2>&1; then
    hostid | tr -d '[:space:]'
    return
  fi
  hostname 2>/dev/null | tr -d '[:space:]' || printf "%s" "unknown-host"
}

generate_collection_id() {
  local machine_id="$1"
  local epoch_seconds="$2"
  local salt="pipa-tree"
  local seed="${machine_id:-unknown}:${epoch_seconds}:${salt}"
  local hash=""
  if command -v sha256sum >/dev/null 2>&1; then
    hash=$(printf "%s" "$seed" | sha256sum | head -c 8)
  elif command -v shasum >/dev/null 2>&1; then
    hash=$(printf "%s" "$seed" | shasum -a 256 | head -c 8)
  elif command -v md5sum >/dev/null 2>&1; then
    hash=$(printf "%s" "$seed" | md5sum | head -c 8)
  else
    local checksum
    checksum=$(printf "%s" "$seed" | cksum | awk '{print $1}')
    hash="${checksum:0:8}"
  fi
  printf "%s" "$hash"
}

run_collect_command() {
  local output_path=""
  local duration_stat=60
  local duration_record=60
  local run_stat=1
  local run_record=1
  local perf_stat_interval=1000
  local sar_interval=1
  local perf_record_freq=97
  local perf_events_override=""
  local no_spec_info=0
  local force_spec_refresh=0

  local session_log_tmp=""
  session_log_tmp=$(mktemp -t pipa_tree_log_XXXX) || log_fatal "Failed to create temporary log file"
  PIPA_TREE_LOG_FILE="$session_log_tmp"

  local collection_epoch=""
  collection_epoch=$(date +%s)
  local machine_identifier=""
  machine_identifier=$(read_machine_identifier)
  local collection_id=""
  collection_id=$(generate_collection_id "$machine_identifier" "$collection_epoch")
  export PIPA_TREE_COLLECTION_ID="$collection_id"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --output)
        [[ $# -ge 2 ]] || log_fatal "--output requires a path"
        output_path="$2"; shift 2 ;;
      --duration-stat)
        [[ $# -ge 2 ]] || log_fatal "--duration-stat requires seconds"
        duration_stat="$2"; shift 2 ;;
      --duration-record)
        [[ $# -ge 2 ]] || log_fatal "--duration-record requires seconds"
        duration_record="$2"; shift 2 ;;
      --no-stat)
        run_stat=0; shift ;;
      --no-record)
        run_record=0; shift ;;
      --perf-stat-interval)
        [[ $# -ge 2 ]] || log_fatal "--perf-stat-interval requires milliseconds"
        perf_stat_interval="$2"; shift 2 ;;
      --sar-interval)
        [[ $# -ge 2 ]] || log_fatal "--sar-interval requires seconds"
        sar_interval="$2"; shift 2 ;;
      --perf-record-freq)
        [[ $# -ge 2 ]] || log_fatal "--perf-record-freq requires Hz"
        perf_record_freq="$2"; shift 2 ;;
      --perf-events)
        [[ $# -ge 2 ]] || log_fatal "--perf-events requires a list"
        perf_events_override="$2"; shift 2 ;;
      --no-spec-info)
        no_spec_info=1; shift ;;
      --force-spec-refresh)
        force_spec_refresh=1; shift ;;
      -h|--help)
        show_collect_usage
        exit 0 ;;
      *)
        log_fatal "Unknown option for collect: $1" ;;
    esac
  done

  if [[ -z "$output_path" ]]; then
    output_path=$(generate_default_output_path)
    log_info "No --output specified. Using default path: $output_path"
  fi

  if (( run_stat == 0 && run_record == 0 )); then
    log_fatal "At least one phase must run"
  fi

  ensure_command tar
  ensure_command perf
  ensure_command sar
  ensure_command sadf

  select_perf_event_groups "$perf_events_override"

  WORK_DIR=$(mktemp -d -t pipa_sample_XXXX)
  trap cleanup_work_dir EXIT
  log_info "Working directory: $WORK_DIR"

  local level_dir="$WORK_DIR/attach_session"
  mkdir -p "$level_dir"

  local final_log_path="$level_dir/pipa-tree.log"
  if [[ -n "$session_log_tmp" && -f "$session_log_tmp" ]]; then
    mv "$session_log_tmp" "$final_log_path"
  else
    : >"$final_log_path"
  fi
  PIPA_TREE_LOG_FILE="$final_log_path"

  local metadata_file="$level_dir/pipa-collection-info.txt"
  {
    printf "collection_id: %s\n" "$collection_id"
    printf "generated_at_epoch: %s\n" "$collection_epoch"
    printf "generated_at_utc: %s\n" "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    printf "machine_identifier: %s\n" "$machine_identifier"
    printf "program_name: %s\n" "$PROGRAM_NAME"
    printf "program_version: %s\n" "$PROGRAM_VERSION"
    printf "target_archive: %s\n" "$output_path"
  } >"$metadata_file"
  printf "%s\n" "$collection_id" >"$level_dir/collection_id.txt"

  log_info "pipa-tree ${PROGRAM_VERSION} initialized. Collection ID: $collection_id"
  log_info "Machine identifier: $machine_identifier"
  log_info "Archive target path: $output_path"
  log_info "Counting duration: ${duration_stat}s, profiling duration: ${duration_record}s"

  prepare_spec_info "$WORK_DIR/spec_info.yaml" "$no_spec_info" "$force_spec_refresh"

  if (( run_stat == 1 )); then
    log_info "Starting counting phase (perf stat + sar) for ${duration_stat}s"
    local perf_stat_file="$level_dir/perf_stat.txt"
    local sar_bin="$level_dir/sar_all.bin"
    local sar_log="$level_dir/sar.log"

    local pid_status=0
    start_perf_stat_job "$duration_stat" "$perf_stat_interval" "$perf_stat_file"
    local perf_job="$LAST_BG_PID"
    start_sar_job "$duration_stat" "$sar_interval" "$sar_bin" "$sar_log"
    local sar_job="$LAST_BG_PID"

    wait "$perf_job" || pid_status=$?
    if grep -q "perf_event_paranoid" "$perf_stat_file" 2>/dev/null; then
      log_fatal "perf stat aborted due to perf_event_paranoid restrictions"
    fi
    wait "$sar_job" || true
    convert_sar_outputs "$sar_bin" "$level_dir"

    log_info "Perf stat data saved to: $perf_stat_file"
  fi

  if (( run_record == 1 )); then
    log_info "Starting profiling phase (perf record) for ${duration_record}s"
    local perf_data="$level_dir/perf.data"
    run_profiling_phase "$duration_record" "$perf_record_freq" "$perf_data"
  fi

  archive_results "$WORK_DIR" "$output_path"
  log_info "Collection complete."
}

main() {
  local command="${1:-}" || true
  if [[ "$command" == "help" || "$command" == "--help" || "$command" == "-h" ]]; then
    show_main_usage
    exit 0
  fi

  if [[ -z "$command" || "$command" == -* ]]; then
    command="collect"
  else
    shift
  fi

  case "$command" in
    sample|collect)
      run_collect_command "$@"
      ;;
    *)
      log_fatal "Unknown command: $command"
      ;;
  esac
}

main "$@"
